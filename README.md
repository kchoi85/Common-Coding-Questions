# Common Coding Questions
List of 75 most frequently asked coding interview questions


## Array

- [x] [Two Sum](https://leetcode.com/problems/two-sum/)
- [x] [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- [x] [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)
- [x] [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)
- [x] [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)
- [x] [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)
- [x] [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
- [ ] [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
- [x] [3Sum](https://leetcode.com/problems/3sum/)
- [x] [Container With Most Water](https://leetcode.com/problems/container-with-most-water/)

---

## Linked List

- [x] [Reverse a Linked List](https://leetcode.com/problems/reverse-linked-list/)
- [x] [Detect Cycle in a Linked List](https://leetcode.com/problems/linked-list-cycle/)
- [x] [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)
- [x] [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
- [x] [Remove Nth Node From End Of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
- [ ] [Reorder List](https://leetcode.com/problems/reorder-list/)

---

## String

- [ ] [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
- [ ] [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)
- [ ] [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)
- [ ] [Valid Anagram](https://leetcode.com/problems/valid-anagram/)
- [ ] [Group Anagrams](https://leetcode.com/problems/group-anagrams/)
- [ ] [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)
- [ ] [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)
- [ ] [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)
- [ ] [Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)
- [ ] [Encode and Decode Strings (Leetcode Premium)](https://leetcode.com/problems/encode-and-decode-strings/)

---

## Dynamic Programming

- [x] [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
- [x] [Coin Change](https://leetcode.com/problems/coin-change/)
- [ ] [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)
- [ ] [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)
- [ ] [Word Break Problem](https://leetcode.com/problems/word-break/)
- [ ] [Combination Sum](https://leetcode.com/problems/combination-sum-iv/)
- [ ] [House Robber](https://leetcode.com/problems/house-robber/)
- [ ] [House Robber II](https://leetcode.com/problems/house-robber-ii/)
- [ ] [Decode Ways](https://leetcode.com/problems/decode-ways/)
- [ ] [Unique Paths](https://leetcode.com/problems/unique-paths/)
- [ ] [Jump Game](https://leetcode.com/problems/jump-game/)

---

## Binary

- [ ] [Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/)
- [ ] [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
- [ ] [Counting Bits](https://leetcode.com/problems/counting-bits/)
- [ ] [Missing Number](https://leetcode.com/problems/missing-number/)
- [ ] [Reverse Bits](https://leetcode.com/problems/reverse-bits/)

---

## Graph

- [ ] [Clone Graph](https://leetcode.com/problems/clone-graph/)
- [ ] [Course Schedule](https://leetcode.com/problems/course-schedule/)
- [ ] [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)
- [ ] [Number of Islands](https://leetcode.com/problems/number-of-islands/)
- [ ] [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)
- [ ] [Alien Dictionary (Leetcode Premium)](https://leetcode.com/problems/alien-dictionary/)
- [ ] [Graph Valid Tree (Leetcode Premium)](https://leetcode.com/problems/graph-valid-tree/)
- [ ] [Number of Connected Components in an Undirected Graph (Leetcode Premium)](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)

---

## Interval

- [ ] [Insert Interval](https://leetcode.com/problems/insert-interval/)
- [ ] [Merge Intervals](https://leetcode.com/problems/merge-intervals/)
- [ ] [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)
- [ ] [Meeting Rooms (Leetcode Premium)](https://leetcode.com/problems/meeting-rooms/)
- [ ] [Meeting Rooms II (Leetcode Premium)](https://leetcode.com/problems/meeting-rooms-ii/)

---

## Matrix

- [ ] [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)
- [ ] [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)
- [ ] [Rotate Image](https://leetcode.com/problems/rotate-image/)
- [ ] [Word Search](https://leetcode.com/problems/word-search/)

---

---

## Tree
- [x] [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
- [x] [Same Tree](https://leetcode.com/problems/same-tree/)
- [x] [Invert/Flip Binary Tree](https://leetcode.com/problems/invert-binary-tree/)
- [ ] [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)
- [x] [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)
- [ ] [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)
- [x] [Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)
- [ ] [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
- [ ] [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)
- [ ] [Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)
- [ ] [Lowest Common Ancestor of BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
- [ ] [Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)
- [ ] [Add and Search Word](https://leetcode.com/problems/add-and-search-word-data-structure-design/)
- [ ] [Word Search II](https://leetcode.com/problems/word-search-ii/)

---

## Heap

- [ ] [Merge K Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
- [ ] [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)
- [ ] [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)

## Important Link:
[14 Patterns to Ace Any Coding Interview Question](https://hackernoon.com/14-patterns-to-ace-any-coding-interview-question-c5bb3357f6ed)

---
```
/* 
387. First Unique Character in a String
s = "leetcode" -> return 0
s = "loveleetcode" -> 2
*/
public int firstUniqueChar(String s) {
    HashMap<Character, Integer> map = new HashMap<Character, Integer>();
    for (int i=0; i<s.length(); i++) {
        char current = s.charAt(i);
        if (!map.containsKey(current)) {
            map.put(current, i);
        } else {
            map.put(current, -1);
        }
    }

    int min = Integer.MAX_VALUE;
    for (char c: map.keySet()) {
        if (map.get(c) > -1 && map.get(c) < min) {
            min = map.get(c);
        }
    }
    return min == Integer.MAX_VALUE ? -1 : min;
} // Time complexity: O(N) since we go through the string length of N

/*
136. Single Number
Given a non-empty array of integers, every element appears twice except for one.
Input: [2,2,1]
Output: 1
*/
public int singleNumber(int[] nums) {
    HashSet<Integer> set = new HashSet<Integer>():
    for (int num: nums) {
        if (!set.contains(num)) {
            set.add(num);
        } else {
            set.remove(num);
        }
    }

    for (int i: set) {
        return i;
    }
    return -1;
} // TC: O(N) since we go thoruhg the length of nums array

/*
231. Power of Two
Given an integer, write a function to determine if it is a power of two
Input: 1
Output: true
Input: 16
Output: true (2^4)
*/
public boolean isPowerOfTwo(int n) {
    long i = 1; // so we don't overflow
    while (i < n) {
        i *= 2;
    }
    return i == n;
} // O(N)

/*
657. Robot Return to Origin
"UD" -> true
"LL" -> false
*/
public boolean judgeCircle(String moves) {
    int UD = 0;
    int LR = 0;
    for (int i=0; i<moves.length(); i++) {
        char current = moves.charAt(i);
        if (current == 'U') {
            UD++;
        } else if (current == 'D') {
            UD--;
        } else if (current == 'L') {
            LR++;
        } else if (current =='R') {
            LR--;
        }
    }
    if (UD == 0 && LR == 0) {
        return true;
    }
    return false;
} // O(N)

/*
268. Missing Number
[3,0,1] -> 2
*/
// When trying to remember we've seen, HashSet is good
public int missingNumber(int[] nums) {
    HashSet<Integer> set = new HashSet<Integer>();
    for (int i: nums) {
        set.add(i);
    }    
    for (int i=0; i<= nums.length; i++) {
        if (!set.contains(i)) {
            return i;
        }
    }
    return -1;
} // O(N)

/*
122. Best Time to Buy and Sell Stock II
[7,1,5,3,6,4] -> 7
Buy on day 2 (price=1) and sell on day 3 (price=5), profit = 5 - 1 = 4
Then buy on day 4 (price=3) and sell on day 5 (price=6), profit = 6 - 3 = 3
*/
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) return 0;

    int profit = 0;
    for (int i=0; i<prices.length - 1; i++) {
        if (prices[i+1] > prices[i]) {
            profit += prices[i+1] - prices[i];
        }
    }
    return profit;
}

/*
112. Path Sum
GIven binary tree and a sum, determine if the tree has a root-to-leaf path 
sums to the sum (22) -> true (5->4->11->2)
       5  
    4    8
  11  13  4
7   2       1
*/ 

// case 1, arrive @ leaf node child == null, false
// case 2, arrive @ leaf node and sum - root.val == 0, true
// otherwise (else) recursive call to left or right to see if true
public boolean hasPathSum(TreeNode root, int sum) {
    // case where we've reached the leaf node's child (which means no path)
    if (root == null) {
        return false;
    } else if (root.right == null && root.left == null && sum - root.val == 0) {
        return true; // case where we are at leaf node and sum - root.val = 0
    } else { // recursive call left and right, subtract the sum - root.val
             // either can return true
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)
    }
}

/*
27. Remove Element
Given array and value, remove all instances of the value from array
and return the length of the array
[0,1,2,2,3,0,4,2], val=2, -> length = 5
*/
public int removeElement(int[] nums, int val) {
    int index = 0;
    for (int i: nums) {
        if (i != val) {
            nums[index++] = i;
        }
    }
    return index; // which keeps the length of the new array
}

/* 
70. Climbing Stairs
In: 2
Out: 2
(1+1) (2)
*/
public int climbingStairs(int n) {
    int[] dp = new int[n + 1]; // dp of 0 = 0; number of ways to climb 0 stairs is 1 way (none)
    dp[0] = 1;
    dp[1] = 1;
    for (int i=2; i<=n; i++) { // up to and including the nth step
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}

/* (medium) !!!Asked by a lot
17. Letter combinations of a Phone Number
https://leetcode.com/problems/letter-combinations-of-a-phone-number/
*/
public List<String> letterCombinations(String digits) {
    List<String> result = new ArrayList<String>();
    if (digits == null || digits.length() == 0) return result;
    
    String[] mapping = {
    "0",
    "1",
    "abc",
    "def",
    "ghi",
    "jkl",
    "mno",
    "pqrs",
    "tuv",
    "wxyz"
};
    
    letterCombinationsRecursive(result, digits, "", 0, mapping);
    return result;
}
public void letterCombinationsRecursive(List<String> result, String digits, String current, int index, String[] mapping) {
    // base case to stop the recursive function
    if (index == digits.length()) {
        result.add(current);
        return;
    }

    String letter = mapping[digits.charAt(index) - '0'];
    for (int i=0; i<letter.length(); i++) {
        letterCombinationsRecursive(result, digits, current + letter.charAt(i), index + 1, mapping);
    }
}

/* 
235. Lowest Common Ancestor of a BST
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
*/
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    // check if p and q are either on the node's left or node's right, if not
    // it's a split (children)
    if (p.val < root.val && q.val < root.val) { // both on left
        return lowestCommonAncestor(root.left, p, q);
    } else if (p.val > root.val && q.val > root.val) {
        return lowestCommonAncestor(root.right, p, q);
    } else {
        return root;
    }
 } //Time complexity is O(h), where h is the height of the tree

// 771. Jewels and Stones
// Given J and S, find how many jewels you have
// J=aA, s=aAAbbbb -> 3

public int jewelsStones(String J, String S) {
    HashSet<Character> jewels = new HashSet<Character>();
    for (char c: J.toCharArray()) {
        jewels.add(c);
    }

    int numJewels = 0;
    for (char c: S.toCharArray()) {
        if (jewels.contains(c)) {
            numJewels++;
        }
    }
    return numJewels;
} // O(M+N)

// 11. Container with Most Water
class Solution {
    public int maxArea(int[] height) {
        int a_pointer = 0;
        int b_pointer = height.length - 1;
        
        int maxA = 0;
        while (a_pointer < b_pointer) {
            if (height[a_pointer] < height[b_pointer]) {
                maxA = Math.max(maxA, height[a_pointer] * (b_pointer-a_pointer));
                a_pointer++;
            } else {
                maxA = Math.max(maxA, height[b_pointer] * (b_pointer-a_pointer));
                b_pointer--;
            }
        }
        return maxA;
    }
}

// 733. Flood Fill
// https://leetcode.com/problems/flood-fill/

// dfs
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        if (image[sr][sc] == newColor) return image;

        // recursive f(x)
        fill(image, sr, sc, image[sr][sc], newColor);
        return image;
    }
    public void fill(int[][] image, int i, int j, int initialColor, int newColor) {
        // check if we are inside the bounds of the image?
        // Are pixels around the same color as the initialColor?
        if (i<0 || i >= image.length || j < 0 || j >=image[i].length || image[i][j] != initialColor) {
            return; 
        }
        image[i][j] = newColor;

        fill(image, i+1, j, initialColor, newColor); //Down
        fill(image, i-1, j, initialColor, newColor); //Up
        fill(image, i, j+1, initialColor, newColor); //Right
        fill(image, i, j-1, initialColor, newColor); //Left
    }
}

// 206. Reverse Linked List
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;
        
        while (current != null) {
            ListNode temp = current.next;
            current.next = prev;
            prev = current;
            current = temp;   
        }
        
        return prev;
    }
}

// 819. Most common word
class Solution {
    public String mostCommonWord(String paragraph, String[] banned) {
        HashSet<String> bannedWords = new HashSet<>();
        for (String word: banned) {
            bannedWords.add(word);
        }

        HashMap<String, Integer> counts = new HashMap<>();
        for (String word: paragraph.replaceAll("[^a-zA-Z]", " ").toLowerCase().split(" ")) {
            if (!bannedWords.contains(word)) {
                counts.put(word, counts.getOrDefault(word, 0) + 1);
            }
        }

        String result = "";
        for (String word: counts.keySet()) {
            if (result.equals("") || counts.get(word) > counts.get(result)) {
                result = word;
            }
        }
        return result;
    }
}

// 929. Unique Email Address
// https://leetcode.com/problems/unique-email-addresses/
class Solution {
    public int numUniqueEmail(String[] emails) {
        HashSet<String> set = new HashSet<String>();
        for (String email: emails) {
            StringBuilder address = new StringBuilder();
            for (int i=0; i<email.length(); i++) {
                char c = email.charAt(i);
                if (c == '.') {
                    continue;
                } else if (c =='+') {
                    while (email.charAt(i) != '@') {
                        i++;
                    }

                    address.append(email.substring(i + 1));
                } else {
                    address.append(c);
                }
            }

            set.add(address.toString())
        }
        return set.size();
    }
}

// 253. Meeting Rooms II
// https://www.youtube.com/watch?v=PWgFnSygweI&list=PLi9RQVmJD2fZgRyOunLyt94uVbJL43pZ_&index=18
// 0 30 , 5 10, 15 20
// 2 5, 7 10
// 2 5, 3 10
class Solution {
    public int minMeetingRooms(Interval[] intervals) {
        if (intervals == null || intervals.length == 0) return 0;

        // lambda function to sort meetings by start time
        Arrays.sort(intervals, (a, b) -> a.start - b.start);

        // minHeap (compare objects, keep tracking of end times)
        // root of the minHeap = meeting that ends the earliest
        PriorityQueue<Interval> minHeap = new PriorityQueue<>((a,b) -> a.end - b.end);
        minHeap.add(intervals[0]);

        for (int i=1; i<intervals.length; i++) {
            Interval current = intervals[i];
            Interval earliest = minHeap.remove();
            if (current.start >= earliest.end) { // >= edge case to consider ending at 2 and starting a new meeting at 2
                earliest.end = current.end;
            } else {
                minHeap.add(current);
            }
            minHeap.add(earliest);
        }
        return minHeap.size();
    }
} //O(N*Log(N))

// Most asked AMAZON QUESTION !!!
// 973. K Closest Points to Origin

/*
Need data structure: MaxHeap
use maxheap to make sure the size of max heap is of size K
when we add to max heap but the size is already K, then we remove the next thing in the heap
(removes the maximum, which is the furthest away from origin)
*/
class Solution {
    public int[][] kClosest(int[][] points, int K) {
        // Euclidean distance (point - origin)
        PriorityQueue<Integer[]> maxHeap = new PriorityQueue<>((a, b) -> (b[0] * b[0] + b[1] * b[1] - (a[0] * a[0] + a[1] * a[1])))
        for (int[] point: points) {
            maxHeap.add(point);
            if (maxHeap.size() > K) {
                maxpHeap.remove();
            } 
        }
        int[][] result = new int[K][2];
        while(K-- > 0) {
            result[K] = maxHeap.remove();
        }

        return result;
    }
}

// 695. Max Area of Island (med)
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int max = 0;
        for (int i=0; i<grid.length; i++) {
            for(int j=0; j<grid[i].length; j++) {
                // if 1 which we found island, we run dfs
                if (grid[i][j] == 1) {
                    max = Math.max(max, dfs(grid, i, j));
                }
            }
        }
        return max;
    }
    public int dfs(int[][] grid, int i, int j) {
        if (i<0 || i>=grid.length || j<0 || j>=grid[i].length || grid[i][j] == 0) {
            return 0;
        }

        grid[i][j] = 0;
        int count = 1;
        count += dfs(grid, i+1, j);
        count += dfs(grid, i-1, j);
        count += dfs(grid, i, j+1);
        count += dfs(grid, i, j-1);
        
        return count;
    }
}

// 403. Frog Jump (Hard)
class Solution {
    public boolean canCross(int[] stones) {
        
    }
}

// 23. Merge K Sorted Lists (hard)
//  throw every list into minHeap, make a new list from the heap
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        // for every list, throw every node into minheap
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (ListNode head: lists) {
            while (head != null) {
                minHeap.add(head.val);
                head = head.next;
            }
        }
        ListNode dummy = new ListNode(-1); // dummy to place hold -1
        // head point to the dummy (reference to the head to add to that list)
        ListNode head = dummy;
        while (!minHeap.isEmpty()) {
            head.next = new ListNode(minHeap.remove()); // remember that minheap stored integer val
            head = head.next;
        }

        return dummy.next;
    }
}

// 49. Grouped Anagrams (medium) !!! frequent
// Input: strs = ["eat","tea","tan","ate","nat","bat"]
// Output: 
//     [
//         ["bat"],
//         ["nat","tan"],
//         ["ate","eat","tea"]
//     ]
class Solution {
    public List<List<String>> groupedAnagrams(String[] strs) {
        List<List<String>> groupedAnagrams = new  ArrayList<>();
        HashMap<String, List<String>> map = new HashMap<>();

        for(String current: strs) {
            char[] characters = current.toCharArray();
            Arrays.sort(characters);
            String sorted = new String(characters);
            if (!map.containsKey(sorted)) {
                map.put(sorted, new ArrayList<>());
            }

            map.get(sorted).add(current);
        }

        groupedAnagrams.addAll(map.values());
        return groupedAnagrams;
    }
}
/* practice
class Solution {
    public List<List<String>> groupedAnagrams(String[] strs) {
        List<List<String>> groupedAnagrams = new ArrayList<>();
        HashMap<String, List<String>> map = new HashMap<>();

        for (String current: strs) {
            char[] character = current.toCharArray();
            Arrays.sort(character);
            String sorted = new String(character);
            if(!map.containsKey(sorted)) {
                map.put(sorted, new ArrayList<>());
            }
            // map.put(sorted, current); wrong!!!
            map.get(sorted).add(current) //arraylist adding is ".add()"
        }

        groupedAnagrams.addAll(map.values());
        // for (List<String> val: map.values()) {
        //     groupedAnagrams.add(val);
        // }

        return groupedAnagrams;
    }
} */

// 62. Unique Paths (Medium) dp
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i=0; i<dp.length; i++) {
            dp[i][0] = 1; // for every row we assign 1 by going down
        }
        for (int i=0; i<dp[0].length; i++) {
            dp[0][i] = 1; // for every column in the 0th row, we assign 1
        }

        // this means that for any cell, we must have come from above or from the left
        // since 0th row and 0th column is already 1,
        for (int i=1; i<dp.length; i++) {
            for (int j=1; j<dp[i].length; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1]; // means we add from top and left
            }
        }
        return dp[m-1][n-1];
    }
}

// 198. House Robber (bottom up processing - dp)
class Solution {
    public int robHouse(int[] nums) {
        // case: 0 house
        if (nums == null || nums.length == 0) return 0;
        // case: 1 house, return nums[0]
        if (nums.length == 1) return nums[0];
        // case 2: 2 houses, rob the house that has more money
        if (nums.length == 2) {
            return Math.max(nums[0], nums[1]);
        }
        // case 3+: 3 houses, do we rob 1st and 3rd or 2nd? (bottom up)
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i=2; i<dp.length; i++) {
            dp[i] = Math.max(nums[i] + nums[i-2], nums[i-1]);
        }
        return dp[nums.length - 1];
    }
}

// 113. Path Sum II (medium)
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
         List<List<Integer>> paths = new ArrayList<>();
         findPaths(root, sum, new ArrayList<Integer>(), paths);
         return paths;
    }

    public void findPaths(TreeNode root, int sum, List<Integer> current, List<List<Integer>> paths) {
        if(root == null) {
            return;
        }
        current.add(root.val);

        if (root.val == sum && root.left == null && root.right == null) {
            paths.add(current);
            return;
        }

        findPaths(root.left, sum - root.val, new ArrayList<Integer> current, paths);
        findPaths(root.right, sum - root.val, new ArrayList<Integer> current, paths);
    }
} //O(N logN)

// 100. Same Tree
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p==null && q==null) return true;
        else if (p==null || q==null) return false;
        else if (p.val != q.val) return false;
        else {
            return isSameTree(p.left, q.left) && isSameTreef(p.right, q.right);
        }
    }
} // traverse entire tree of p and q, -> same amount of nodes -> O(N)

// 104. Maximum depth of BST
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int left_depth = maxDepth(root.left) + 1;
        int right_depth = maxDepth(root.right) + 1;
        return Math.max(left_depth, right_depth);
    }
}

// 101. Symmetric Tree
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return isSymmetricRecursive(root.left, root.right);
    }
    public boolean isSymmetricRecursive(TreeNode left, TreeNode right) {
        if (left == null && right == null) return true; // this order matters
        if (left == null || right == null) return false;
        return (left.val == right.val) && isSymmetricRecursive(left.left, right.right) && isSymmetricRecursive(left.right, right.left);
    }
} // O(N)

// 286. Walls and Gates
class Solution {
    public void wallsAndGates(int[][] rooms) {
        for (int i=0; i<rooms.length; i++) {
            for (int j=0, j<rooms[i].length; j++) {
                if (rooms[i][j] == 0) {
                    dfs(i,j,0,rooms);
                }
            }
        }
    }
    public void dfs(int i, int j, count, int[][] rooms) {
        if (i<0 || i>=rooms.length || j<0 || j>=rooms[i].length, rooms[i][j] < count) {
            return;
        }
        rooms[i][j] = count;
        dfs(i+1, j, count+1, rooms);
        dfs(i-1, j, count+1, rooms);
        dfs(i, j+1, count+1, rooms);
        dfs(i, j-1, count+1, rooms);
    }
}
```

